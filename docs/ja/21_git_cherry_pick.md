## 取り戻しましょう。`git cherry-pick`

前回、reflogを使って、破棄されたローカルの変更を見つける方法を学習しました。 今回は以下の場合を学習しましょう。

### 1つの特定のコミットが欲しい場合

チェリーピックは、reflogもしくは、プロジェクトの他のブランチからのコミットを拾い、現在のブランチに移動させることができます。 現在のファイルディレクトリとログは以下のようになっているはずです。

```shell-session
$ ls
README.md
$ git log --oneline
84nqdkq initializing repo with README
```

ファイル4を追加したコミットをチェリーピックしましょう。

1. file4.mdを追加したコミットIDを見つけます。`git reflog`
2. そのコミットをチェリーピックします。`git cherry-pick <SHA>`

ディレクトリとログを見ると、以下のように表示されているはずです。

```shell-session
$ ls
file4.md
README.md
$ git log --oneline
eanu482 adding file 4
84nqdkq initializing repo with README
```

コミットIDは、チェリーピックのコマンドで使用したものと同じでしょうか？ なぜそうなっているのでしょうか？

> 履歴を変更するコマンドは、GitHubにプッシュする前に使用することが重要です。 すでにリモートにプッシュされているコミットのIDを変更してしまうと、コラボレータに問題が発生する恐れがあります。 {: .warning}

### おっと、誤ってリセットしちゃった

時折、`git reset --hard` を意図した範囲よりも広く使用してしまい、それを復元させたいという時があります。 幸いなことに、`git reset --hard` は、遡るだけでなく、前に進めることもできます。

1. HEADが指してきた全ての場所の履歴を表示します。`git reflog`
2. 元の`file6.md`が作成された時点にリセットします。`git reset --hard <SHA>`
3. 復元された履歴を表示します。`git log --oneline`

`git log --oneline`のコミットIDを `git reflog` と比較してみましょう。 気づきましたか？

> すでにファイル4をチェリーピックしたのに、なぜこのコマンドはマージコンフリクトを起こさなかったでしょうか。 その理由は、`git reset --hard` が2つの履歴をマージしようとしているわけではなく、新しいコミットを指すようブランチを移動しただけだからです。 それが今回の狙いでした。 しかし違う場面では、元のリセット後に行った作業が全て失われてしまう可能性があります。

便利なエイリアスを利用して悲惨な失敗を回避する方法について、Appendix に記載しています。ご参照ください。
